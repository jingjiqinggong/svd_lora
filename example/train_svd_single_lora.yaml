# Pretrained diffusers model path.
pretrained_model_path: "stabilityai/stable-video-diffusion-img2vid"
huggingface_cache_dir: "/home/jchuang/huggingface_cache/"
# lora_path: only for eval
# lora_path: null
lora_path: "./checkpoint/train_2024-01-28T23-28-33/checkpoint-2000"
# only finetuning unet is supported now
unet_lora_target_modules:
  - 'to_q'
  - 'to_k'
  - 'to_v'
  - 'to_out.0'

# These two parameters are currently useless
motion_mask: False
motion_strength: False

# The folder where your training outputs will be placed.
output_dir: "./shan-myout"

# You can train multiple datasets at once. They will be joined together for training.
# Simply remove the line you don't need, or keep them all for mixed training.

# Currently, only support single_video
# 'image': A folder of images and captions (.txt)
# 'folder': A folder a videos and captions (.txt)
# 'video_blip': The JSON file created with automatic BLIP2 captions using https://github.com/ExponentialML/Video-BLIP2-Preprocessor
# 'video_json': a video foler and a json caption file
# 'single_video': A single video file.mp4 and text prompt
dataset_types: 
  - 'single_video'
  #- 'folder'
  #- 'image'
  #- 'video_blip'
  #- 'video_json'

# Adds offset noise to training. See https://www.crosslabs.org/blog/diffusion-with-offset-noise
# If this is enabled, rescale_schedule will be disabled.
offset_noise_strength: 0.1
use_offset_noise: False

# Uses schedule rescale, also known as the "better" offset noise. See https://arxiv.org/pdf/2305.08891.pdf
# If this is enabled, offset noise will be disabled.
rescale_schedule: False

# When True, this extends all items in all enabled datasets to the highest length. 
# For example, if you have 200 videos and 10 images, 10 images will be duplicated to the length of 200. 
extend_dataset: False

# Caches the latents (Frames-Image -> VAE -> Latent) to a HDD or SDD. 
# The latents will be saved under your training folder, and loaded automatically for training.
# This both saves memory and speeds up training and takes very little disk space.
cache_latents: False  

# If you have cached latents set to `True` and have a directory of cached latents,
# you can skip the caching process and load previously saved ones. 
cached_latent_dir: null #/path/to/cached_latents

# Train the text encoder for the model. LoRA Training overrides this setting.
# train_text_encoder: False

# https://github.com/cloneofsimo/lora (NOT Compatible with webui extension)
# This is the first, original implementation of LoRA by cloneofsimo.
# Use this version if you want to maintain compatibility to the original version.

# https://github.com/ExponentialML/Stable-LoRA/tree/main (Compatible with webui text2video extension)
# This is an implementation based off of the original LoRA repository by Microsoft, and the default LoRA method here.
# It works a different by using embeddings instead of the intermediate activations (Linear || Conv).
# This means that there isn't an extra function when doing low ranking adaption.
# It solely saves the weight differential between the initialized weights and updates. 

# "cloneofsimo" or "stable_lora"
# lora_version: "stable_lora"

# # Use LoRA for the UNET model.
# use_unet_lora: True

# # Use LoRA for the Text Encoder. If this is set, the text encoder for the model will not be trained.
# use_text_lora: False

# LoRA Dropout. This parameter adds the probability of randomly zeros out elements. Helps prevent overfitting.
# See: https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html
# lora_unet_dropout: 0.1

# lora_text_dropout: 0.1

# https://github.com/kabachuha/sd-webui-text2video
# This saves a LoRA that is compatible with the text2video webui extension.
# It only works when the lora version is 'stable_lora'.
# This is also a DIFFERENT implementation than Kohya's, so it will NOT work the same implementation.
# save_lora_for_webui: False

# The LoRA file will be converted to a different format to be compatible with the webui extension.
# The difference between this and 'save_lora_for_webui' is that you can continue training a Diffusers pipeline model
# when this version is set to False
# only_lora_for_webui: False

# Choose whether or not ito save the full pretrained model weights for both checkpoints and after training.
# The only time you want this off is if you're doing full LoRA training.
save_pretrained_model: True

# # useless
# # The modules to use for LoRA. Different from 'trainable_modules'.
# unet_lora_modules:
#   # - "UNet3DConditionModel"
#   #- "ResnetBlock2D"
#   # - "TransformerTemporalModel"
#   # - "Transformer2DModel"
#   - "TransformerSpatioTemporalModel"
#   - "BasicTransformerBlock"
#   #- "CrossAttention"
#   #- "Attention"
#   #- "GEGLU"
#   #- "TemporalConvLayer"

## useless
# # The modules to use for LoRA. Different from `trainable_text_modules`.
# text_encoder_lora_modules:
#   - "CLIPEncoderLayer"
#   #- "CLIPAttention"

# The rank for LoRA training. With ModelScope, the maximum should be 1024. 
# VRAM increases with higher rank, lower when decreased.
# lora_rank: 16
lora_rank: 8

# Training data parameters
train_data:

  # The width and height in which you want your training data to be resized to.
  width:  512
  height: 512

  # This will find the closest aspect ratio to your input width and height. 
  # For example, 512x512 width and height with a video of resolution 1280x720 will be resized to 512x256
  # use_bucketing: False
  use_bucketing: True
  return_mask: True
  return_motion: True

  # The start frame index where your videos should start (Leave this at one for json and folder based training).
  # 目前代码只出现再VideoBLIPDataset  SingleVideoDataset
  # useless
  sample_start_idx: 1

  # Used for 'folder'. The rate at which your frames are sampled. Does nothing for 'json' and 'single_video' dataset.
  # high fps, lower frame step, move slowly
  fps: 7

  # !![Note] Now, during each training_step, n_sample_frames are seleted with 'frame_step' as the interval.
  # For 'single_video' and 'json'. The number of frames to "step" (1,2,3,4) (frame_step=2) -> (1,3,5,7, ...).  
  # frame_step: 1
  frame_step: 24

  # The number of frames to sample. The higher this number, the higher the VRAM (acts similar to batch size).
  n_sample_frames: 7
  
  # 'single_video'
  single_video_path: "./img_video/dog512_2.mp4"
  # single_video_path: "./img_video/4.mp4"

  # [Note] useless, prompt is not supported now
  # The prompt when using a a single video file
  single_video_prompt: "a dog"

  # Fallback prompt if caption cannot be read. Enabled for 'image' and 'folder'.
  fallback_prompt: ''
  
  # # 'folder'
  # #path: "/data2/webvid/data/videos/004151_004200"
  # path: "/data/datasets/msvd/videos_mp4"

  # # 'json'
  # json_path: '/webvid/animation1.json'

  # # 'image'
  # image_dir: '/vlp/datasets/images/coco'
  # image_json: '/vlp/datasets/images/coco/coco_karpathy_train.json'

  # video_dir: '/webvid/webvid/data/videos'
  # video_json: '/webvid/webvid/data/40K.json'
  # The prompt for all image files. Leave blank to use caption files (.txt) 
  single_img_prompt: ""

 
# Validation data parameters.
validation_data:
  # [Note] useless, prompt is not supported now
  # A custom prompt that is different from your training dataset. 
  prompt: "a dog moves body"

  prompt_image: "img_video/1.png"

  # Whether or not to sample preview during training (Requires more VRAM).
  sample_preview: True

  # The number of frames to sample during validation.  会影响 guidance_scale (不同帧用不同guidance scale)
  # num_frames: 14
  num_frames: 7

  # Height and width of validation sample.
  width: 512
  height: 512

  # Number of inference steps when generating the video.
  num_inference_steps: 25

  # CFG scaled   useless  没用上
  guidance_scale: 9

  # fps
  fps: 7

  # useless  函数finetune_uet 里面设置成了127
  # The motion bucket ID. Used as conditioning for the generation. The higher the number the more motion will be in the video.
  motion_bucket_id: 127

  # The number of frames to decode at a time. The higher the chunk size, the higher the temporal consistency between frames,
  # but also the higher the memory consumption. By default, the decoder will decode all frames at once for maximal quality.
  # Reduce `decode_chunk_size` to reduce memory usage.
  # <= num_frames 
  decode_chunk_size: 7
  # decode_chunk_size: 28

# Learning rate for AdamW
# learning_rate: 5e-6
# learning_rate: 1e-4
learing_rate: 5e-4

# Weight decay. Higher = more regularization. Lower = closer to dataset.
adam_weight_decay: 0

# Optimizer parameters for the UNET. Overrides base learning rate parameters.
extra_unet_params: null
  #learning_rate: 1e-5
  #adam_weight_decay: 1e-4

# Optimizer parameters for the Text Encoder. Overrides base learning rate parameters.
extra_text_encoder_params: null
  #learning_rate: 1e-4
  #adam_weight_decay: 0.2

# How many batches to train. Not to be confused with video frames.
train_batch_size: 1
# Maximum number of train steps. Model is saved after training.
# max_train_steps: 10000
max_train_steps: 10

# Saves a model every nth step.
checkpointing_steps: 5000

# How many steps to do for validation if sample_preview is enabled.
validation_steps: 2000

# Which modules we want to unfreeze for the UNET. Advanced usage.
# trainable_modules: 
#   #- "all"
#   # If you want to ignore temporal attention entirely, remove "attn1-2" and replace with ".attentions"
#   # This is for self attetion. Activates for spatial and temporal dimensions if n_sample_frames > 1
#   - "attn1"
#   #- ".attentions"
  
#   # This is for cross attention (image & text data). Activates for spatial and temporal dimensions if n_sample_frames > 1
#   - "attn2"
#   #- "conv_in"
  
#   #  Convolution networks that hold temporal information. Activates for spatial and temporal dimensions if n_sample_frames > 1
#   #- "temp_conv"
#   #- "motion"


# Which modules we want to unfreeze for the Text Encoder. Advanced usage.
# trainable_text_modules: null

# Seed for validation.
seed: 6

# Whether or not we want to use mixed precision with accelerate
mixed_precision: "fp16" #"fp16"

# This seems to be incompatible at the moment.
use_8bit_adam: False 

# Trades VRAM usage for speed. You lose roughly 20% of training speed, but save a lot of VRAM.
# If you need to save more VRAM, it can also be enabled for the text encoder, but reduces speed x2.
gradient_checkpointing: True
text_encoder_gradient_checkpointing: False

# Xformers must be installed for best memory savings and performance (< Pytorch 2.0)
enable_xformers_memory_efficient_attention: True

# Use scaled dot product attention (Only available with >= Torch 2.0)
enable_torch_2_attn: True


# 保存每次抽取的视频段
save_train_sample: False